{
  "_comment": "排序算法分镜模板 — 适用于：冒泡排序、选择排序、插入排序",
  "_usage": "将此模板填入 storyboard.json，替换所有 FILL_IN 占位符，选择对应排序算法的描述",
  "title": "FILL_IN_题目名称（如：冒泡排序）",
  "subject": "算法",
  "algorithm_type": "sorting",
  "operation": "FILL_IN（bubble_sort / selection_sort / insertion_sort）",
  "color_legend": {
    "C_NODE_DEFAULT": "未处理的元素（深蓝）",
    "C_SORT_CMP":     "正在比较的元素（琥珀，同时高亮两格）",
    "C_SORT_SWAP":    "被交换的元素（红，交换过程中）",
    "C_SORT_DONE":    "已排好序的元素（绿，不再移动）"
  },
  "segments": [
    {
      "id": "intro",
      "segment_no": 1,
      "type": "title_card",
      "duration_hint_s": "4~6",
      "narration": "今天我们来学习「FILL_IN_排序算法名」！口诀是：FILL_IN_口诀。",
      "narration_examples": {
        "bubble":    "今天我们来学习「冒泡排序」！口诀是：相邻比大小，大的往后冒。",
        "selection": "今天我们来学习「选择排序」！口诀是：每轮找最小，放到最前面。",
        "insertion": "今天我们来学习「插入排序」！口诀是：摸一张牌，往左找位置插进去。"
      },
      "visual": {
        "layout": "居中铺满",
        "elements": [
          {"role": "主标题", "text": "FILL_IN_排序算法名", "style": "font_size=52, BOLD, WHITE"},
          {"role": "副标题/口诀", "text": "FILL_IN_口诀", "style": "font_size=28, C_MUTED"}
        ],
        "animation_sequence": [
          "FadeIn(主标题, shift=UP*0.3), run_time=0.8",
          "FadeIn(副标题), run_time=0.5",
          "wait(约3秒)",
          "FadeOut(VGroup)"
        ]
      }
    },
    {
      "id": "problem",
      "segment_no": 2,
      "type": "text_card",
      "duration_hint_s": "8~12",
      "narration": "FILL_IN_完整朗读题目。说明初始数组和排序目标。",
      "narration_examples": {
        "bubble": "给定数组 [5, 3, 8, 4, 2]，请用冒泡排序把它从小到大排好。",
        "selection": "给定数组 [64, 25, 12, 22, 11]，请用选择排序从小到大排列。"
      },
      "visual": {
        "layout": "居中带圆角深蓝卡片",
        "elements": [
          {"role": "角标签", "text": "题  目", "style": "font_size=18, C_MUTED, to_corner(UL)"},
          {
            "role": "题目文本",
            "lines": [
              "FILL_IN_第一行（如：给定数组 [5, 3, 8, 4, 2]）",
              "FILL_IN_第二行（如：请用冒泡排序从小到大排列）",
              "FILL_IN_第三行（如：输出：[2, 3, 4, 5, 8]）"
            ],
            "style": "font_size=26, C_TEXT, 左对齐"
          }
        ]
      }
    },
    {
      "id": "draw",
      "segment_no": 3,
      "type": "array_draw",
      "duration_hint_s": "5~8",
      "narration": "FILL_IN_描述画数组过程。画出每个元素的格子，标出初始值。",
      "narration_example": "我们先把初始数组画出来：5、3、8、4、2，现在还是乱的，需要我们来排序。",
      "visual": {
        "layout": "数组水平居中，y=0；格子大小0.7，无索引标签（排序用格子颜色区分状态）",
        "manim_objects": {
          "cell":    "make_cell(val, None, pos, size=0.7)  → 注意idx参数传None，只显示值",
          "storage": "self._cells = [cell_VGroup, ...]"
        },
        "array_values": "FILL_IN_初始数组（如：[5, 3, 8, 4, 2]）",
        "layout_formula": {
          "n": "len(arr)",
          "start_x": "-(n-1) * 0.35",
          "cell_x":  "start_x + i * 0.7"
        },
        "animation_sequence": [
          "self.play(LaggedStart(*[FadeIn(c) for c in self._cells], lag_ratio=0.1), run_time=0.8)",
          "wait(约4秒)"
        ]
      }
    },
    {
      "id": "operation_1",
      "segment_no": 4,
      "type": "sort_first_pass",
      "duration_hint_s": "16~22",
      "narration": "FILL_IN_描述第一轮排序的完整过程。说明每次比较和交换。不超过80字。",
      "narration_examples": {
        "bubble_pass1": "冒泡排序第一轮：先比较5和3，5比3大，交换！变成3和5。再比5和8，5小，不用换。比8和4，8大，交换！比8和2，8大，再换！第一轮结束，最大的8冒到最右边了，变绿色！",
        "selection_pass1": "选择排序第一轮：用一个指针从左到右扫描，找最小值。先记住第一个数64是当前最小，然后扫到25，25更小，更新最小；继续找到12，再更新；22不比12小，11比12小，最终最小值是11。把11和64交换，11放到最左边，变绿！",
        "insertion_pass1": "插入排序从第二个元素开始。取出3，它比5小，5往右移，把3插到5的左边。数组变成[3,5,8,4,2]。"
      },
      "visual": {
        "bubble_sort": {
          "compare_step": [
            "1. 同时高亮两格变 C_SORT_CMP：",
            "   self.play(cells[i][0].animate.set_fill(C_SORT_CMP), cells[i+1][0].animate.set_fill(C_SORT_CMP))",
            "2. 显示比较符号（Text 放两格中间上方，wait(0.3)，FadeOut）",
            "3. 若需要交换（cells[i].val > cells[i+1].val）：",
            "   两格变 C_SORT_SWAP",
            "   self.play(cells[i].animate.shift(RIGHT*0.7), cells[i+1].animate.shift(LEFT*0.7))",
            "   在 self._cells 列表中交换引用：self._cells[i], self._cells[i+1] = self._cells[i+1], self._cells[i]",
            "4. 比较完后两格变回 C_NODE_DEFAULT（除非已排好）",
            "5. 轮末：最右未排序的格变 C_SORT_DONE"
          ]
        },
        "selection_sort": {
          "scan_step": [
            "1. 扫描指针：Arrow 从左到右移动（Arrow.animate.shift(RIGHT*0.7)）",
            "2. 当前最小值格：外加 SurroundingRectangle(min_cell, color=C_RANGE_MID) 标注",
            "3. 找到更小值时：旧 SurroundingRectangle FadeOut，新的 FadeIn",
            "4. 扫描结束后：min格和首位格交换（同冒泡交换动画）",
            "5. 最小值放到正确位置后变 C_SORT_DONE"
          ]
        },
        "insertion_sort": {
          "insert_step": [
            "1. 取出当前元素（cells[i]），显示'取出'标签",
            "2. 向左扫描，每个比当前元素大的格子向右平移0.7",
            "3. 找到插入位置后，当前元素移到该位置（shift 动画）",
            "4. 已处理部分（左侧）变 C_SORT_DONE"
          ]
        },
        "round_label": "每轮开始显示 Text('第1轮')，round_time=0.3，FadeOut 在轮末",
        "done_section": {
          "bubble": "每轮末尾，右侧新排好的格变 C_SORT_DONE（从右向左扩大）",
          "selection": "每轮末尾，左侧新排好的格变 C_SORT_DONE（从左向右扩大）",
          "insertion": "每轮末尾，左侧已排好的格变 C_SORT_DONE"
        }
      }
    },
    {
      "id": "operation_2",
      "segment_no": 5,
      "type": "sort_more_passes",
      "duration_hint_s": "12~18",
      "narration": "FILL_IN_描述第二轮及后续轮次（可加速展示）。不超过60字。",
      "narration_examples": {
        "bubble": "继续第二轮，注意最右边的8已经排好了不用管了。比较3和5，不用换；5和4换；5和2换。第二轮结束，5也排好了！就这样一轮一轮，越来越多的数排好了。",
        "selection": "第二轮从剩余元素中再找最小值：12。放到第二位，变绿！第三轮找到22，第四轮找到25，最后一个就是64。",
        "insertion": "继续取出第三个元素8，8比5大不用动。取出4，比8小，8右移，比5大，插到5和8之间。取出2，它是最小的，一路向左插到最前面。"
      },
      "visual": {
        "layout": "与 operation_1 相同模式，但适当加速（run_time 缩短0.3×）",
        "speed_note": "后续轮次 run_time 可以缩短：比较步骤0.3s，交换0.4s（比第一轮快约0.5×）",
        "done_tracking": "每轮结束后，已排好的格（边界继续向未排序区扩展）保持 C_SORT_DONE",
        "round_labels": "Text('第2轮')、Text('第3轮')… 在每轮开始 FadeIn，轮末 FadeOut"
      }
    },
    {
      "id": "result",
      "segment_no": 6,
      "type": "sort_result",
      "duration_hint_s": "6~8",
      "narration": "FILL_IN_描述排序完成结果。",
      "narration_examples": {
        "bubble": "排序完成！所有元素都变绿了，从小到大排列：2、3、4、5、8。",
        "selection": "选择排序完成！结果是：11、12、22、25、64。"
      },
      "visual": {
        "elements": [
          {
            "role": "所有格变绿",
            "action": "AnimationGroup([c[0].animate.set_fill(C_SORT_DONE) for c in cells], lag_ratio=0.1)"
          },
          {
            "role": "结果数组文字",
            "text": "FILL_IN_已排序数组（如：[ 2, 3, 4, 5, 8 ]）",
            "style": "result_box(text)，to_edge(DOWN)"
          }
        ],
        "animation_sequence": [
          "AnimationGroup 所有格变绿",
          "DrawBorderThenFill(结果框)",
          "FadeIn(结果文字)",
          "wait(约4秒)"
        ]
      }
    },
    {
      "id": "summary",
      "segment_no": 7,
      "type": "answer_reveal",
      "duration_hint_s": "10~14",
      "narration": "FILL_IN_总结排序结果和关键规则。不超过50字。",
      "narration_examples": {
        "bubble":    "冒泡排序的结果是2、3、4、5、8！口诀：大的往后冒。n个元素需要n-1轮，时间复杂度O(n²)。",
        "selection": "选择排序结果是11、12、22、25、64！口诀：找最小放前面。时间复杂度O(n²)，不稳定排序。",
        "insertion": "插入排序结果是2、3、4、5、8！口诀：摸牌往左插。时间复杂度O(n²)，但对基本有序的数组很快！"
      },
      "visual": {
        "layout": "清空前一段，居中铺满",
        "elements": [
          {"role": "问题回顾", "text": "FILL_IN（如：排序后的数组 =）", "style": "font_size=34, C_MUTED"},
          {"role": "大号答案", "text": "FILL_IN_已排序数组", "style": "result_box, font_size=46"},
          {"role": "关键提示", "text": "FILL_IN_💡口诀 + 时间复杂度 O(n²)", "style": "insight_box"}
        ],
        "animation_sequence": [
          "FadeOut(self._result_grp)",
          "FadeIn(问题回顾)",
          "DrawBorderThenFill(答案框) + FadeIn(答案)",
          "DrawBorderThenFill(提示框) + FadeIn(提示)",
          "wait(约8秒)"
        ]
      }
    }
  ]
}
